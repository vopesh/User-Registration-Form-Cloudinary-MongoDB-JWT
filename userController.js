import fs from "fs";
import { user } from "../models/users.js";
import { v2 as cloudinary } from "cloudinary";
import bcrypt from "bcryptjs";
import { logger } from "../src/utils/logger.js";
import jwt from "jsonwebtoken";

// Cloudinary configuration
cloudinary.config({
  cloud_name: process.env.CLOUDINARY_CLOUD_NAME,
  api_key: process.env.CLOUDINARY_API_KEY,
  api_secret: process.env.CLOUDINARY_API_SECRET,
});

// for home page
export const getHomePage = (req, res) => {
  res.render("register.ejs");
};

// for login page
export const loginpage = (req, res) => {
  res.render("login", {
    loggedIn: !!req.session.userId, // optional: for logout button
  });
};

// when user registered then show most recent 10 users
export const getUserList = async (req, res) => {
  try {
    const recentUsers = await user
      .find()
      .select("name email fullPhone country photo cloudinaryURL")
      .sort({ createdAt: -1 })
      .limit(10);

    res.render("user-list.ejs", {
      users: recentUsers,
      isRemembered: req.session?.isRemembered || false, // ‚úÖ Add this
      loggedIn: !!req.session?.userId, // ‚úÖ Optional, to show logout button
    });
  } catch (err) {
    logger.error("‚ö†Ô∏è Error in getUserList:", err.message);
    res.status(500).render("error.ejs", {
      error: "Could not load user list",
    });
  }
};

export const registerUser = async (req, res) => {
  logger.info("Received registration data:", req.body);
  let cloudinaryResult;

  try {
    // 1. Validate required fields
    if (!req.file) {
      return res.status(400).render("register.ejs", {
        error: "Please upload a profile photo",
      });
    }

    // 2. Upload to Cloudinary
    cloudinaryResult = await cloudinary.uploader.upload(req.file.path, {
      folder: "vopesh-lec18-user-profiles",
      resource_type: "image",
    });

    // 3. Create and save user
    const newUser = new user({
      name: req.body.name,
      country: req.body.country,
      countryCode: req.body.country_code,
      phone: req.body.phone,
      email: req.body.email,
      password: req.body.password, // Ensure this is hashed via pre-save hook
      photo: cloudinaryResult.public_id,
      cloudinaryURL: cloudinaryResult.secure_url,
      // fullPhone will be auto-generated by schema
    });

    await newUser.save();

    // 4. Clean up temp file
    fs.unlinkSync(req.file.path);

    // 5. Show success page
    res.render("user.ejs", {
      user: newUser,
      success: "Registration successful!",
    });
  } catch (error) {
    logger.error("Registration error:", error);

    // Cleanup in case of error
    if (req.file?.path) {
      try {
        fs.unlinkSync(req.file.path);
      } catch (fsError) {
        logger.error("Failed to delete temp file:", fsError);
      }
    }

    if (cloudinaryResult?.public_id) {
      try {
        await cloudinary.uploader.destroy(cloudinaryResult.public_id);
      } catch (cloudinaryError) {
        logger.error("Failed to delete Cloudinary upload:", cloudinaryError);
      }
    }

    // Handle duplicate email error specifically
    const errorMessage =
      error.code === 11000
        ? "Email already exists"
        : error.message || "Registration failed. Please try again.";

    res.status(400).render("register.ejs", {
      error: errorMessage,
    });
  }
};

export const loginUser = async (req, res) => {
  logger.info("üß™ Raw body from login:", req.body);
  const { email, password, rememberMe } = req.body;
  logger.info("üìå rememberMe value from form:", rememberMe);

  try {
    const foundUser = await user.findOne({ email }).select("+password");

    if (!foundUser) {
      req.flash("error_msg", "Invalid email or password.");
      return res.redirect("/login");
    }

    if (foundUser.lockUntil && foundUser.lockUntil > Date.now()) {
      const minutes = Math.ceil(
        (foundUser.lockUntil - Date.now()) / (1000 * 60)
      );
      req.flash(
        "error_msg",
        `Account locked due to too many failed attempts. Try again in ${minutes} minute(s).`
      );
      return res.redirect("/login");
    }

    const isMatch = await bcrypt.compare(password, foundUser.password);

    if (!isMatch) {
      foundUser.failedLoginAttempts += 1;

      if (foundUser.failedLoginAttempts >= 3) {
        foundUser.lockUntil = new Date(Date.now() + 5 * 60 * 1000);
        await foundUser.save();
        req.flash(
          "error_msg",
          "Too many failed attempts. You are locked for 5 minutes."
        );
        return res.redirect("/login");
      } else {
        const remaining = 3 - foundUser.failedLoginAttempts;
        await foundUser.save();
        req.flash(
          "error_msg",
          `Incorrect credentials. ${remaining} attempt(s) left.`
        );
        return res.redirect("/login");
      }
    }

    // ‚úÖ Single-session logic
    if (
      foundUser.loginStatus === "on" &&
      foundUser.sessionId &&
      foundUser.sessionId !== req.session.id
    ) {
      logger.warn("üîê User is already logged in elsewhere. Resetting session.");
    }

    foundUser.failedLoginAttempts = 0;
    foundUser.lockUntil = null;
    foundUser.loginStatus = "on";
    foundUser.sessionId = req.session.id;
    await foundUser.save();

    // ‚úÖ Issue JWT
    const accessToken = jwt.sign(
      {
        userId: foundUser.userId,
        email: foundUser.email,
      },
      process.env.JWT_SECRET,
      {
        expiresIn: "15m", // short-lived access
        algorithm: "HS256",
      }
    );

    // Optional: Store accessToken in memory or send via HTTP-only cookie if needed

    // ‚úÖ SSR session setup
    req.session.userId = foundUser._id;
    req.session.userData = {
      name: foundUser.name,
      email: foundUser.email,
      fullPhone: foundUser.fullPhone,
      country: foundUser.country,
      cloudinaryURL: foundUser.cloudinaryURL,
    };

    const rememberSelected = rememberMe === "on";
    req.session.isRemembered = rememberSelected;
    req.session.cookie.maxAge = rememberSelected
      ? 1000 * 60 * 60 * 24 * 7
      : 1000 * 60 * 5;

    req.session.save((err) => {
      if (err) {
        logger.error("Session save error:", err);
        req.flash("error_msg", "Login failed. Please try again.");
        return res.redirect("/login");
      }

      if (rememberSelected) {
        logger.info("üü¢ Remember Me enabled: Session set for 7 days");
      } else {
        logger.info("üü° Remember Me not checked: Session set for 5 minutes");
      }

      logger.info("üü° Session info:", req.session);
      logger.info("üîê Access Token issued:", accessToken);

      // You can send token in a cookie, header or just attach to session if browser based
      res.redirect("/profile");
    });
  } catch (error) {
    logger.error("Login error:", error);
    req.flash("error_msg", "Login failed. Please try again.");
    res.redirect("/login");
  }
};

export const logoutUser = async (req, res) => {
  try {
    const sessionType = req.session.isRemembered
      ? "üîµ Persistent session"
      : "üü° Standard session";
    console.log(`${sessionType}: Logging out...`);

    // ‚úÖ Set flash message *before* destroying session
    req.flash("success", "You have been logged out.");

    // ‚úÖ Fix: extract userId from session
    const userId = req.session?.userId;

    // ‚úÖ Update DB to invalidate login
    if (userId) {
      await user.findByIdAndUpdate(userId, {
        loginStatus: "off",
        sessionId: null,
      });
    }

    req.session.destroy((err) => {
      if (err) {
        console.error("Logout error:", err);
        // ‚ö†Ô∏è You cannot use req.flash() here anymore, session is gone
        return res.redirect("/login");
      }

      res.clearCookie("connect.sid"); // Optional cleanup
      return res.redirect("/login");
    });
  } catch (err) {
    console.error("Logout exception:", err);
    res.redirect("/login"); // Avoid using flash here too
  }
};
